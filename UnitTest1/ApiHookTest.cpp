
#include "CppUnitTest.h"
#include <iostream>
#include <Process\Hook\apihook.h>
#include <Process\Hook\EatHook.h>
#include <string>
#include <strstream>
#include <Process\LazyLoad\LazyLoad.h>
using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace std;
using Process::Hook::HookApi32;
using Process::Hook::HookApi32Ex;

// 测试结果输出到vs中
namespace UnitTest1
{		
	using Process::Hook::GetInstructionLen;
	// 测试32位部分的opcode解析,代码有解析64位功能,但是要手动输入太多测试数据所以没测
	TEST_CLASS(OpcodeTest_x32)
	{
		
	public:
		
		OpcodeTest_x32()
		{
			this->gol = make_shared<GetInstructionLen>(new Process::Hook::GetInstructionLen(true));
		}
		~OpcodeTest_x32()
		{
		}
		TEST_METHOD(Opcode_Normal_x32)
		{
			// 从代码里复制出来的,是有意义的汇编代码
			Logger::WriteMessage("一般指令解析测试1");
			BYTE code[] = { 0x55,0x8B,0xEC,0x6A,0xFF,0x68,0xE8,0x65,0x99,0x00,0x64,0xA1,0x00,0x00,0x00,0x00,
							0x50,0x81,0xEC,0x18,0x01,0x00,0x00,0x53,0x56,0x57,0x8D,0xBD,0xDC,0xFE,0xFF,0xFF,
							0xB9,0x46,0x00,0x00,0x00,0xB8,0xCC,0xCC,0xCC,0xCC,0xF3,0xAB,0xA1,0x08,0x11,0x9A,
							0x00,0x33,0xC5,0x89,0x45,0xF0,0x50,0x8D,0x45,0xF4,0x64,0xA3,0x00,0x00,0x00,0x00,
							0xC7,0x45,0xE8,0x01,0x00,0x00,0x00,0x6A,0x34,0x8D,0x4D,0xAC,0xE8,0x1B,0x48,0xFE,
							0xFF,0x6A,0x01,0x8D,0x4D,0xAC,0xE8,0x6B,0x48,0xFE,0xFF,0xC7,0x45,0xFC,0x00,0x00,
							0x00,0x00 
			};
			// 以上16进制数据的正确解析组合
			BYTE codeLen[] = {1,2,2,5,6,1,6,1,1,1,6,5,5,2,5,2,3,1,3,6,7,2,3,5,2,3,5,7
			};
			// 将代码解出的数据跟正确数据比对
			GetLen(code, codeLen, sizeof(code));

			Logger::WriteMessage("一般指令解析测试2");
			BYTE code2[] = { 0xB7,0xFE,0xFF,0x83,0xC4,0x08,0x50,0xE8,0x95,0xB6,0xFE,0xFF,0x83,0xC4,0x08,0x50,
							 0xE8,0x8C,0xB6,0xFE,0xFF,0x83,0xC4,0x08,0x8B,0xC8,0xFF,0x15,0x1C,0x41,0x33,0x01,
							 0x3B,0xDC,0xE8,0xD8,0xAD,0xFE,0xFF,0x8B,0xC8,0xFF,0x15,0x28,0x41,0x33,0x01,0x3B,
							 0xFC,0xE8,0xC9,0xAD,0xFE,0xFF,0x8B,0xC8,0xFF,0x15,0x18,0x41,0x33,0x01,0x3B,0xF4,
							 0xE8,0xBA,0xAD,0xFE,0xFF,0xA1,0x04,0x30,0x33,0x01,0x83,0xE8,0x02,0xA3,0x04,0x30,
							 0x33,0x01,0x83,0x3D,0x04,0x30,0x33,0x01,0x02,0x7D,0x0A,0xC7,0x05,0x04,0x30,0x33,
							 0x01,0x02,0x00,0x00,0x00,0xE9,0xBD,0xF5,0xFF,0xFF 
			};
			BYTE codeLen2[] = { 2,6,1,2,6,6,6,1,2,2,5,2,6,2,5,2,6,2,5,5,3,5,7,2,10,5 };
			GetLen(code2, codeLen2, sizeof(code2));


		}
		TEST_METHOD(Opcode_OneAndTwoByte_x32)
		{
			// 乱组合的，不能运行，纯用来测试解析,几乎涉及到了一二字节的所有组合(有一些重复特征的指令忽略),OD不一定能全部解析, 所有的正确解析数据都来自vs的反汇编
			Logger::WriteMessage("比较全的指令解析测试x32(都是可以正确解析的指令,无3字节opcode指令)");
			BYTE code[] = { 0x01,0x84,0x83,0xEE,0xFC,0x11,0xDB,0x01,0xC4,0x02,0x00,0x02,0x44,0x75,0x07,0x02,
							0x50,0xE8,0x02,0x74,0x01,0xDB,0x03,0x45,0xE8,0x03,0x80,0xF6,0x40,0x8A,0x06,0x04,
							0x88,0x05,0x47,0x01,0xDB,0x75,0x06,0x07,0x08,0x90,0x90,0x90,0x90,0x90,0x09,0x90,
							0x90,0x90,0x90,0x90,0x0A,0x90,0x90,0x90,0x90,0x90,0x0B,0x7F,0xFB,0x0C,0x30,0x0D,
							0x40,0x00,0x55,0x8B,0x0E,0x0F,0x00,0x84,0x14,0x64,0xFF,0x30,0x64,0x0F,0x00,0x8B,
							0xEC,0x33,0xC0,0x55,0x0F,0x01,0x65,0xA5,0x0F,0x02,0x1A,0x0F,0x03,0x30,0x0F,0x05,
							0x0F,0x06,0x0F,0x07,0x0F,0x08,0x0F,0x09,0x0F,0x0B,0x0F,0x0D,0x06,0x0F,0x0D,0x84,
							0x7B,0xB7,0x40,0x70,0xED,0x0F,0x10,0x5D,0xC3,0x0F,0x11,0x97,0x77,0x7F,0x69,0x04,
							0x0F,0x12,0x32,0x0F,0x13,0x92,0x04,0x6F,0xFF,0xFF,0x0F,0x14,0xD2,0x0F,0x15,0x57,
							0x51,0x0F,0x16,0xC7,0x0F,0x17,0x31,0x0F,0x18,0x57,0xF4,0x0F,0x18,0x84,0x4E,0x64,
							0x8B,0x4D,0x08,0x0F,0x20,0xD1,0x0F,0x28,0xFB,0x0F,0x29,0xAA,0x88,0x5D,0xC2,0x04,
							0x0F,0x2C,0x2B,0x0F,0x2D,0xC1,0x0F,0x2E,0x00,0x0F,0x2F,0x53,0x56,0x0F,0x30,0x0F,
							0x34,0x0F,0x40,0xF9,0x0F,0x41,0x99,0xD9,0x77,0xFF,0x89,0x0F,0x42,0xF3,0x0F,0x43,
							0x59,0x5F,0x0F,0x44,0x57,0x56,0x0F,0x45,0x84,0x44,0x4C,0x77,0xB3,0x59,0x0F,0x46,
							0x29,0x0F,0x47,0x5F,0x3E,0x0F,0x48,0xF0,0x0F,0x49,0xFF,0x0F,0x4A,0xAE,0x45,0xFF,
							0x3B,0xD0,0x0F,0x4B,0x2B,0x0F,0x4D,0x40,0x33,0x0F,0x4E,0x1C,0x11,0x0F,0x4E,0xC0,
							0x0F,0x4F,0x1E,0x0F,0x51,0x6D,0x7F,0x0F,0x52,0x58,0x29,0x0F,0x53,0xF8,0x0F,0x54,
							0x5E,0xC3,0x0F,0x55,0xE6,0x0F,0x56,0x20,0x0F,0x57,0x84,0xDF,0xFE,0x52,0x56,0x31,
							0x0F,0x58,0x48,0x75,0x0F,0x59,0xBF,0x6D,0xED,0xDB,0x18,0x0F,0x5C,0x5E,0x5B,0x0F,
							0x5D,0x90,0x76,0x33,0xF6,0x3E,0x0F,0x5E,0x8A,0x18,0x83,0xFB,0xED,0x0F,0x5F,0xFC,
							0x0F,0x60,0x10,0x0F,0x61,0xF7,0x0F,0x62,0x80,0xC2,0x30,0x80,0xFA,0x0F,0x63,0x03,
							0x0F,0x64,0x8C,0x16,0x09,0xC0,0x75,0xBB,0x0F,0x65,0xFF,0x0F,0x66,0x5A,0x29,0x0F,
							0x67,0xCA,0x0F,0x68,0x2B,0x0F,0x69,0x88,0xCC,0x14,0x36,0x7F,0x0F,0x6A,0x55,0x83,
							0x0F,0x6B,0x74,0x66,0x08,0x0F,0x6E,0x6C,0xB7,0xED,0x0F,0x6F,0xE9,0x0F,0x70,0x01,
							0xD1,0x0F,0x71,0x22,0xD6,0x0F,0x72,0x75,0xFA,0x88,0x0F,0x72,0x94,0x97,0xBE,0x56,
							0x8B,0xF0,0x8B,0x0F,0x72,0xA4,0xB7,0xFF,0xC0,0x7D,0x88,0x07,0x0F,0x73,0x56,0x8A,
							0xBC,0x0F,0x74,0xFF,0x0F,0x75,0x05,0x24,0x72,0x16,0x42,0x0F,0x76,0x0C,0x06,0x0F,
							0x77,0x0F,0x7E,0x91,0x12,0x3E,0x74,0x4C,0x0F,0x7F,0x1D,0x81,0xFB,0xF0,0xA7,0x0F,
							0x80,0xFD,0x54,0x7F,0x17,0x0F,0x84,0x26,0x66,0x6E,0x82,0x0F,0x88,0x66,0x8B,0x6B,
							0x08,0x0F,0x90,0x80,0xDF,0x6F,0x3F,0x67,0x0F,0x9A,0x06,0x0F,0x9A,0x94,0x04,0x44,
							0x58,0xFC,0x43,0x0F,0xA0,0x0F,0xA1,0x0F,0xA3,0x5C,0xEB,0x73,0x0F,0xA4,0x03,0xFF,
							0x0F,0xA5,0x04,0x90,0x0F,0xAB,0x17,0x0F,0xAC,0x57,0x8B,0xDA,0x0F,0xAD,0xFC,0x0F,
							0xAE,0x00,0x0F,0xAF,0x16,0x0F,0xB0,0xD8,0x0F,0xB1,0x15,0x20,0xEB,0x62,0x08,0x0F,
							0xB2,0xDD,0x0F,0xB3,0x79,0x10,0x0F,0xB4,0x40,0xEB,0x0F,0xB5,0xCE,0x0F,0xB6,0x33,
							0x0F,0xB7,0xB6,0x33,0x0E,0x00,0x04,0x0F,0xBA,0x69,0x00,0x00,0x0F,0xBB,0x00,0x0F,
							0xBC,0x00,0x0F,0xBD,0x94,0x0F,0xBE,0x00,0x0F,0xBF,0x0F,0xBE,0x8C,0x00,0x00,0x00,
							0x00,0x00,0x0F,0xC0,0xFF,0x0F,0xC2,0x1A,0xB7,0x0F,0xC4,0xC8,0x1D,0x0F,0xC5,0x6C,
							0x01,0xEB,0x0A,0x0F,0xC6,0xEB,0x05,0x0F,0xC7,0x0B,0x0F,0xC7,0x8C,0x32,0xEB,0x0C,
							0x41,0x40,0x0F,0xC8,0x0F,0xD1,0x0F,0x0F,0xD1,0xC3,0x0F,0xD2,0x1C,0x6E,0x0F,0xD3,
							0xFE,0x0F,0xD5,0x40,0xE2,0x0F,0xD7,0x4E,0x50,0x0F,0xD8,0x00,0x0F,0xDA,0x9C,0x68,
							0x29,0x10,0x14,0x64,0x0F,0xDA,0xEC,0x0F,0xE0,0x80,0xFB,0x0F,0x75,0x12,0x0F,0xE1,
							0x0F,0x0F,0xE2,0xBF,0xBB,0xC7,0x6F,0x42,0x0F,0xE3,0x42,0x0C,0x0F,0xE4,0x35,0x81,
							0xE3,0xE0,0x24,0x0F,0xE5,0x0F,0x0F,0xE7,0xC7,0x0F,0xE8,0x64,0x89,0x20,0x0F,0xE9,
							0x00,0x0F,0xF1,0x06,0x0F,0xF2,0x9D,0x05,0x40,0xCA,0x20,0x0F,0xF3,0x8B,0xD8,0x43,
							0x54,0x1B,0x0F,0xF5,0x06,0x0F,0xF6,0xED,0x0F,0xF7,0x03,0x0F,0xF8,0x80,0xFB,0xBB,
							0xDD,0x26,0x0F,0xF9,0x9C,0x1A,0x10,0x68,0x30,0x30,0x0F,0xFE,0xA4,0xFF,0x00,0xEB,
							0xF8,0x5D,0x10,0x75,0x07,0x11,0x1E,0x12,0xEE,0x13,0x04,0xDB,0x14,0xC0,0x15,0xD4,
							0x01,0xDB,0x75,0x16,0x17,0x18,0xC0,0x19,0x68,0x29,0x1A,0x14,0x64,0x1B,0x30,0x1C,
							0x89,0x1D,0xFF,0x05,0x00,0x70,0x1E,0x1F,0x28,0xBB,0xDD,0x26,0x5A,0x59,0x29,0x1A,
							0x2A,0x68,0x30,0x2B,0xC3,0x2C,0xD2,0x2D,0x00,0xEB,0xF8,0x5D,0x2E,0x81,0x96,0x83,
							0xEC,0x20,0x51,0x82,0xFD,0xDF,0x83,0x2E,0x8B,0xC0,0x2F,0x30,0xC9,0x31,0x83,0xEE,
							0xFC,0x11,0xDB,0x32,0x52,0x31,0x33,0x83,0xE8,0x03,0x72,0x11,0x34,0xE0,0x35,0x8A,
							0x06,0x46,0x83,0x36,0xFF,0x74,0x75,0xD1,0x37,0x38,0x5C,0x73,0xBB,0x39,0x3D,0x01,
							0xC3,0x77,0x7F,0x3A,0xB9,0xE4,0x32,0x20,0x70,0x3B,0x92,0x04,0x6F,0xFF,0xFF,0x3C,
							0x85,0x3D,0x74,0x1F,0x57,0x51,0x3E,0x89,0xC7,0x3F,0x40,0x41,0x42,0x42,0x44,0x45,
							0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,0x50,0x51,0x52,0x53,0x54,0x55,
							0x56,0x57,0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,0x61,0x62,0x63,0xDB,0x63,0x07,
							0x64,0x1E,0x65,0xEE,0x66,0x01,0x84,0xFC,0x11,0xDB,0x72,0x1F,0x66,0x02,0x71,0x22,
							0x66,0x05,0x1E,0x83,0x66,0x0F,0x00,0x8C,0x00,0x70,0x16,0x7F,0xFB,0x66,0x0F,0x11,
							0x97,0x5C,0x73,0xBB,0x2D,0x66,0x0F,0x89,0x8D,0xFE,0x66,0x11,0xDB,0x66,0x67,0x82,
							0x94,0x00,0x8A,0x07,0x66,0x67,0xB5,0x03,0x66,0x67,0xC7,0x84,0x02,0x20,0x00,0x23,
							0x66,0x71,0xFC,0x66,0x80,0x84,0xC7,0x04,0x83,0xE9,0x04,0x77,0x66,0x81,0x84,0x88,
							0x07,0x47,0x49,0x75,0xF7,0xE9,0x66,0x83,0x04,0x00,0x8B,0x66,0x83,0x05,0x83,0xC7,
							0x05,0x88,0xD8,0x66,0x83,0x06,0x01,0x66,0x83,0x84,0x01,0x00,0x86,0xC4,0x29,0xF8,
							0x66,0x9A,0x10,0x01,0xD1,0xB0,0x66,0xB3,0x09,0x66,0xC2,0x58,0x50,0x66,0xC7,0x84,
							0x0C,0x1F,0x34,0xF3,0x21,0x35,0x20,0x66,0xD2,0x90,0x90,0x90,0x90,0x90,0x66,0xDF,
							0x84,0xFB,0xED,0x7F,0x1B,0xFC,0x66,0xF7,0x00,0x00,0x00,0x67,0x01,0x84,0x28,0x8B,
							0x67,0x03,0x80,0xDB,0x72,0x67,0x0F,0x45,0x84,0x44,0x57,0x67,0x0F,0x8A,0x78,0x0C,
							0xD8,0x0C,0x67,0x66,0x03,0x81,0x00,0x00,0x67,0x72,0x11,0x67,0x80,0x84,0xE9,0x2C,
							0xFF,0x67,0x81,0x84,0xFF,0x8B,0x02,0x83,0xC2,0x04,0x67,0x83,0x05,0xBE,0x67,0x83,
							0x84,0x04,0x66,0xC1,0x67,0x85,0x45,0x8B,0x67,0x9A,0xD6,0xEB,0x03,0x88,0x04,0x16,
							0x67,0xB4,0xC0,0x67,0xBE,0x01,0xDB,0x75,0x07,0x67,0xC2,0x80,0x60,0x67,0xCA,0x8B,
							0x4D,0x67,0xD3,0x90,0x90,0x90,0x67,0xDF,0x84,0x33,0xDB,0x68,0xD9,0x77,0xFF,0x89,
							0x69,0x5F,0xF3,0xA4,0x5E,0x59,0x5F,0x69,0x9C,0x51,0x50,0x30,0x44,0x4C,0x77,0xB3,
							0x59,0xDB,0x6A,0x1A,0x6B,0x29,0xD7,0x6C,0x6D,0x6E,0x6F,0x70,0x1E,0x73,0x73,0x74,
							0x73,0x75,0x75,0x76,0x8B,0x77,0x83,0x78,0x5E,0x79,0x56,0x7A,0x36,0x7B,0x6D,0x7C,
							0x7C,0x7D,0x7D,0x7E,0x7E,0x7F,0x7F,0x80,0x44,0x5E,0x89,0xF7,0x80,0x72,0xFF,0xFF,
							0x80,0x84,0xE4,0x83,0xC1,0x02,0x81,0xFD,0x80,0xFC,0x11,0x81,0x84,0x02,0x8D,0x14,
							0x2F,0x83,0xFD,0xFC,0x76,0x0E,0x82,0x8C,0xE8,0x3C,0x01,0x77,0xF7,0x80,0x83,0x4C,
							0x75,0xF2,0x8B,0x84,0x09,0x86,0x04,0x8D,0x84,0x30,0xD4,0x8A,0x87,0x00,0x88,0x6C,
							0x5E,0xC3,0x8A,0x56,0x31,0x8B,0xB9,0x10,0x00,0x00,0xF7,0x8C,0x4E,0x80,0x8D,0x30,
							0x8E,0xFA,0x8F,0x00,0x8F,0x40,0xBB,0x8F,0x80,0x03,0x0E,0x07,0x88,0x90,0x91,0x92,
							0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0xE5,0x59,0x5A,0x29,0xF1,0x29,0x9B,0x9C,
							0x9D,0x9E,0x9F,0xA0,0x8B,0x09,0x00,0x95,0xA1,0x07,0x47,0x08,0xC0,0xA2,0xDC,0x89,
							0xF9,0x79,0xA3,0x0F,0xB7,0x07,0x47,0xA4,0xA5,0xA6,0xA7,0xA8,0xA4,0xA9,0xFF,0xC0,
							0x7D,0x88,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xF2,0xB1,0x55,0xB2,0x96,0xB6,0xB6,
							0xB7,0xEB,0xB8,0x8B,0xF0,0x8B,0xC6,0xB9,0x0E,0x8A,0xBC,0x8B,0xBA,0xFF,0x7F,0xC1,
							0x05,0xBB,0x72,0x16,0x42,0xB8,0xBC,0x0C,0x06,0x80,0xC1,0xBD,0x80,0xE9,0x1A,0x73,
							0xBE,0x80,0x2C,0x06,0x20,0xBF,0xF8,0x7B,0xB7,0x40,0xC0,0x8B,0x09,0x00,0x8B,0xAE,
							0x7C,0xC0,0x8C,0x00,0x8D,0xBE,0x00,0xF0,0xFF,0xC0,0xFF,0x96,0xC1,0x0F,0x02,0xC1,
							0x8C,0x04,0x53,0x57,0xFF,0xD5,0x8D,0xC1,0xBB,0x00,0x10,0x00,0x00,0x50,0xC2,0x00,
							0x80,0xC3,0xC4,0x53,0x57,0xC4,0x94,0x58,0x61,0x8D,0x44,0x24,0xC5,0x6A,0x00,0xC6,
							0x84,0xEC,0x80,0xE9,0x0D,0x70,0xFD,0xC6,0xC4,0x75,0xC7,0x84,0x12,0x34,0x56,0x78,
							0x90,0x12,0x34,0x56,0x70,0xC8,0xED,0x5E,0x5D,0xC9,0xCA,0xC6,0x01,0xCB,0xCC,0xCD,
							0x82,0xCF,0xD0,0x00,0xD0,0x3C,0xD1,0xD0,0x84,0x33,0xC1,0x20,0x72,0x00,0xD0,0x8C,
							0x90,0x90,0x90,0x90,0x90,0xD0,0x90,0x90,0x90,0x90,0x90,0xD0,0x91,0xAA,0x88,0x5D,
							0xC2,0xD0,0xC0,0xD0,0xF3,0xD0,0xFF,0xD1,0x55,0xFF,0xD1,0x90,0x90,0x90,0x90,0x90,
							0xD2,0xFB,0xD3,0x84,0xFF,0xAE,0x45,0xFF,0x3B,0xD4,0x7D,0xD4,0x90,0xD5,0x8C,0xD5,
							0x90,0xD6,0xD6,0xD7,0xD8,0x84,0x40,0x33,0xC9,0x8D,0x1C,0xD8,0x9C,0x04,0x1E,0x20,
							0x41,0x48,0xD8,0xC0,0xD9,0xF5,0xDA,0xBF,0x6D,0xED,0xDB,0x18,0xDB,0xC0,0xDC,0xCC,
							0xDE,0x44,0x90,0x76,0xE0,0x90,0xE1,0x90,0xE2,0x90,0xE3,0x90,0xE4,0x90,0xE5,0x90,
							0xE6,0x90,0xE7,0x90,0xE8,0x7F,0x2B,0x0F,0x84,0xE9,0xCC,0x14,0x36,0x7F,0xEA,0x74,
							0x55,0x83,0xEB,0x26,0x74,0xEB,0x08,0xEC,0xED,0xEE,0xEF,0xF0,0x90,0xF1,0xF3,0x0F,
							0x2A,0xD1,0xF4,0xF5,0xF6,0x84,0x90,0x90,0x90,0x90,0x90,0x90,0xF6,0x90,0x90,0x90,
							0x90,0x90,0xF7,0x44,0x90,0x90,0x90,0x90,0x90,0x90,0xF7,0x90,0x90,0x90,0x90,0x90,
							0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0x00,0xFE,0x44,0x4C,0x27,0xFE,0x84,0x81,0xFB,
							0xF0,0xA7,0x3D,0xFF,0x84,0xFB,0xFF,0xC3,0x8D,0x40 };
			BYTE codeLen[] = {  7,2,2,4,3,4,3,6,2,5,1,1,6,6,6,3,2,5,1,8,
								7,4,3,3,2,2,2,2,2,2,3,8,4,7,3,7,3,4,3,3,
								4,8,3,3,7,3,3,3,4,2,2,3,7,3,4,4,8,3,4,3,
								3,7,3,4,4,3,3,4,4,3,4,3,3,8,4,7,4,7,7,3,
								3,3,7,3,8,3,4,3,3,7,4,5,5,3,4,4,5,9,9,5,
								3,7,4,2,7,7,6,6,6,7,3,8,2,2,5,4,4,3,5,3,
								3,3,3,7,3,4,4,3,3,7,5,3,3,8,8,3,4,4,6,4,
								3,8,2,3,3,4,3,4,4,3,8,3,7,3,7,4,7,3,3,5,
								3,3,7,7,3,3,3,7,8,8,3,2,2,3,2,5,1,1,2,3,
								3,2,2,5,1,1,6,2,3,2,2,5,11,3,1,2,6,3,6,2,
								5,5,1,4,6,6,6,2,5,3,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
								1,1,1,1,3,2,2,2,8,4,4,9,8,5,3,7,4,8,3,9,
								10,5,8,4,9,6,3,4,10,7,8,5,5,5,6,7,6,3,6,9,
								4,6,4,8,3,6,4,4,5,5,5,7,11,2,3,1,1,1,1,2,
								2,2,2,2,2,2,2,2,2,2,2,2,2,5,4,8,3,11,8,5,
								2,7,2,4,3,6,3,2,2,2,3,6,1,1,1,1,1,1,1,1,
								1,1,7,1,1,1,1,1,5,5,5,5,1,1,1,1,2,5,1,1,
								1,1,1,1,2,2,2,2,2,5,5,5,5,5,5,5,5,7,8,3,
								3,8,7,3,1,3,7,3,8,3,11,4,1,3,1,1,2,1,2,3,
								7,7,6,6,2,2,2,3,6,2,7,2,2,2,2,1,1,1,7,7,
								2,2,6,2,2,4,2,2,2,2,2,2,2,2,5,5,7,2,1,1,
								1,1,2,1,4,1,1,8,6,8,6,1,1,1,1,1,1,2,4,7,7 };
			GetLen(code, codeLen, sizeof(code));

		}
		TEST_METHOD(Opcode_ThreeByte_x32)
		{
			Logger::WriteMessage("3字节opcode测试（部分）");
			BYTE code[] = { 
				0x0F,0x38,0x00,0x03,0x0F,0x38,0x01,0x44,0x90,0x90,0x66,0x0F,0x38,0x03,0x44,0x90,
				0x90,0x66,0x0F,0x38,0x08,0x44,0x01,0x23,0x66,0x0F,0x38,0x10,0x90,0x90,0x90,0x90,
				0x90,0x66,0x0F,0x38,0x20,0x90,0x90,0x90,0x90,0x90,0x66,0x0F,0x38,0x25,0x90,0x90,
				0x90,0x90,0x90,0x66,0x0F,0x38,0x2B,0x4C,0x01,0x23,0x66,0x0F,0x38,0x33,0x9C,0x01,
				0x23,0x45,0x67,0x33,0x66,0x0F,0x38,0x3C,0x15,0x34,0x78,0x12,0x56,0x66,0x0F,0x38,
				0x40,0x9C,0x01,0x23,0x45,0x67,0x33,0x66,0x0F,0x38,0x81,0x9C,0x01,0x23,0x45,0x67,
				0x33,0x66,0x0F,0x38,0xDB,0x22,0x66,0x0F,0x38,0xF0,0x94,0x01,0x23,0x45,0x67,0x33,
				0x66,0x0F,0x38,0xF6,0x44,0x01,0x23,0x66,0x0F,0x3A,0x0F,0x74,0x34,0x78,0x12,0x66,
				0x0F,0x3A,0x14,0x94,0x34,0x78,0x12,0x56,0x33,0xC0,0x66,0x0F,0x3A,0x20,0x94,0x34,
				0x78,0x12,0x56,0x33,0xC0,0x66,0x0F,0x3A,0x62,0x74,0x34,0x78,0x12,0x66,0x0F,0x3A,
				0xDF,0x7C,0x24,0x18,0x72 };
			BYTE codeLen[] = { 4,6,7,7,9,9,9,7,10,9,10,10,5,10,7,8,11,11,8,8 };
			GetLen(code, codeLen, sizeof(code));

		}
		TEST_METHOD(Opcode_Test_x32)
		{
			Logger::WriteMessage("附加测试(包含3字节指令，OD可能解不出来,vs可以解析,结果是用各个指令长度输出一个三角形)");
			BYTE code[] = { 
				0xf8,0xfe,0x00,0xca,0xc6,0x01,0x0f,0x38,0x00,0x03,0x66,0x0f,0x38,0xdb,0x22,0x0f,
				0x38,0x01,0x44,0x90,0x90,0x9a,0xe5,0x59,0x5a,0x29,0xf1,0x29,0x82,0x8c,0xe8,0x3c,
				0x01,0x77,0xf7,0x80,0x66,0x0f,0x38,0x25,0x90,0x90,0x90,0x90,0x90,0x66,0x0f,0x38,
				0x33,0x9c,0x01,0x23,0x45,0x67,0x33,0x81,0x84,0x02,0x8d,0x14,0x2f,0x83,0xfd,0xfc,
				0x76,0x0e,0x64,0x69,0x9C,0x51,0x50,0x30,0x44,0x4C,0x77,0xB3,0x59,0xDB,0x66,0x0f,
				0x3a,0x14,0x94,0x34,0x78,0x12,0x56,0x33,0xc0,0xc7,0x05,0x04,0x30,0x33,0x01,0x02,
				0x00,0x00,0x00,0x67,0x81,0x84,0xff,0x8b,0x02,0x83,0xc2,0x04,0xc0,0x8c,0x00,0x8d,
				0xbe,0x00,0xf0,0xff,0xc0,0x8b,0x09,0x00,0x8b,0xae,0x7c,0x8f,0x80,0x03,0x0e,0x07,
				0x88,0xbe,0x80,0x2c,0x06,0x20,0xc8,0xed,0x5e,0x5d,0xd1,0x55,0xff,0xeb,0x08,0xee };
			BYTE codeLen[] = { 1,2,3,4,5,6,7,8,9,10,11,12,11,10,9,8,7,6,5,4,3,2,1 };
			GetLen(code, codeLen, sizeof(code));

		}
	private:
		shared_ptr<GetInstructionLen> gol;
	
		void PrintHex(PBYTE code, BYTE len)
		{
			string output;
			CHAR tmpStr[3];
			for (BYTE i = 0; i < len; i++)
			{
				auto current = *(code + i);
				if (current<0x10)
				{
					output += "0";
				}
				output += itoa(current, tmpStr, 16);
				output += " ";
			}
			Logger::WriteMessage(output.c_str());
		}
		void GetLen(PBYTE code, PBYTE verify, int codeSize)
		{
			WCHAR tmpStr[64];
			int codeIndex = 0;
			for (int i = 0; i < codeSize; )
			{
				auto len = gol->GetLen(code + i);
				
				if (verify[codeIndex] != len)
				{
					swprintf_s(tmpStr,
						sizeof(tmpStr)/sizeof(WCHAR),
						L"指令长度解析不正确: %d,\r\nLen: %d  Real: %d  FirstByte: %X", 
						codeIndex, len, verify[codeIndex], *(code + i));

					Assert::Fail(tmpStr);
				}
				PrintHex(code + i, len);
				codeIndex++;
				i += len;
			}
		
			swprintf_s(tmpStr, sizeof(tmpStr) / sizeof(WCHAR), L"-成功-\r\n共%d条指令\r\n", codeIndex);

			Logger::WriteMessage(tmpStr);
		}
	};



	// 下面测试apihook, 使用opcode解析器获取字节指令长度, 备份并替换执行
	typedef int (WINAPI* MBOX)(HWND, LPCSTR, LPCSTR, UINT);
	// 旧函数地址不能使用局部变量,否则会丢失
	static MBOX oldAddr1;
	static MBOX oldAddr2;
	int WINAPI MessageBoxA_Hook1(
		_In_opt_ HWND hWnd,
		_In_opt_ LPCSTR lpText,
		_In_opt_ LPCSTR lpCaption,
		_In_ UINT uType)
	{
		Logger::WriteMessage("Hook1 Success");
		string str;
		str += lpText;
		str += "\r\n-Hook1 Success";
		return oldAddr1(hWnd, str.c_str(), lpCaption, uType);
	}
	int WINAPI MessageBoxA_Hook2(
		_In_opt_ HWND hWnd,
		_In_opt_ LPCSTR lpText,
		_In_opt_ LPCSTR lpCaption,
		_In_ UINT uType)
	{
		Logger::WriteMessage("Hook2 Success");
		string str;
		str += lpText;
		str += "\r\n-Hook2 Success";
		return oldAddr2(hWnd, str.c_str(), lpCaption, uType);
	}

	int WINAPI MessageBoxA_Hook3(
		_In_opt_ HWND hWnd,
		_In_opt_ LPCSTR lpText,
		_In_opt_ LPCSTR lpCaption,
		_In_ UINT uType)
	{
		Logger::WriteMessage("Hook3 Success");
		// 做一些操作
		if (strcmp(lpText, "Hello World!"))
		{
			lpText = "你好世界！";
		}
		return ShellAboutA(hWnd, lpCaption, lpText, NULL);
	}
	TEST_CLASS(HookApiTest_x32)
	{
	public:		
		TEST_METHOD(Hook_MessageBox_x32)
		{
			// hook 1次，此时如果调用返回地址会调用原函数
			oldAddr1=(decltype(&MessageBoxA))HookApi32(MessageBoxA, MessageBoxA_Hook1);
			MessageBoxA(NULL, "Hello World!", "第 1 次", NULL);

			// hook 2次,重复hook，第二次继续调用返回地址，连带运行到之前的hook1
			oldAddr2= (MBOX)HookApi32(MessageBoxA, MessageBoxA_Hook2);
			MessageBoxA(NULL, "Hello World!", "第 2 次", NULL);
			// 不用就清掉
			delete[] (PVOID)oldAddr1;
			delete[] (PVOID)oldAddr2;

			// hook 3次，此时不再调用返回地址，调用链断开，不会执行到hook2
			// 把函数替换为另一个,不用执行原函数了就删掉返回内容
			delete[] HookApi32(MessageBoxA, MessageBoxA_Hook3);
			MessageBoxA(NULL, "Hello World!", "第 3 次", NULL);
			MessageBoxA(NULL, "123123123", "多余的示例", NULL);
		}
		
		static void Fail(const wchar_t* message, const __LineInfo* pLineInfo)
		{
			Logger::WriteMessage(message);
		}
		TEST_METHOD(Hook_Fail_x32)
		{
			// hook成功将会绕过fail
			auto output = HookApi32Ex(Assert::Fail, Fail);
			delete[] (PVOID)output;
			//output(L"X", NULL);
			
			Assert::Fail(L"You cannot pass!");
			Logger::WriteMessage("通过！");
			Assert::Fail(L"You ― shall not ― pass!");
			Logger::WriteMessage("通过！");
		}
	};






	// 延迟载入dll的hook因为需要修改项目配置,可能会影响其它测试函数,所以不测试
	// 由于编译的不是pe,是由其它宿主进程(是一个.net程序)载入的,该进程的iat里没有user32,所以不测试
	// 这几个hook包括下面的hook,在测试项目里会受到限制,所以转到exe中测试
	TEST_CLASS(OtherHookTest)
	{
	public:
		// 由于宿主进程把函数地址保存了副本,所以修改导出表后直接调用函数执行的还是旧函数,
		// 所以在hook后使用相当于getprocaddress的方式取出函数地址,此时取到的地址就是hook后的
		TEST_METHOD(EATHook)
		{
			using Process::LazyLoad::User32_Dll;
			PVOID oldFunc=NULL;
			bool isHooked = false;
			MessageBoxA(0, "eat", "eat hook", 0);
			oldFunc = Process::Hook::HookEat(L"user32.dll", "MessageBoxA", MessageBoxA_Hook3);
			// 使用后
			if (!oldFunc)
			{
				Assert::Fail(L"没有取到函数");
			}
			// 必须先load
			if (!User32_Dll.Load() || !User32_Dll._MessageBoxA)
			{
				Assert::Fail();
			}
			User32_Dll._MessageBoxA(0, "eat", "eat hook", 0);


		}
	};

}